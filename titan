#!/usr/bin/env perl
# Copyright (C) 2017‚Äì2020  Alex Schroeder <alex@gnu.org>

# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
# details.
#
# You should have received a copy of the GNU Affero General Public License along
# with this program. If not, see <https://www.gnu.org/licenses/>.

=encoding utf8

=head1 Titan

This is a script to upload content to a Titan-enabled site like Gemini Wiki. It takes up to three arguments:

=over

=item the Titan URL to use; this should be really similar to the Gemini URL you
      used to read the page

=item the token to use; this is optional but spammers and vandals basically
      ensured that any site out on the Internet needs some sort of protection;
      how to get a token depends on the site you're editing

=item the file to upload; this is optional: you can also use a pipe, or type a
      few words by hand (terminating it with a Ctrl-D, the end of transmission
      byte)

=back

Usage:

    echo "This is my test." > test.txt
    titan titan://alexschroeder.ch/Test hello text.txt

Or from a pipe:

    echo "This is my test." \
      | titan titan://alexschroeder.ch/Test hello

=cut

use Modern::Perl '2018';
use Pod::Text;
use URI::Escape;
use File::Basename;
use File::Temp qw(tempfile);
use IO::Socket::SSL;

# Help
if ($ARGV[0] and $ARGV[0] eq '--help') {
  my $parser = Pod::Text->new();
  $parser->parse_file($0);
  exit;
}

# Regular arguments
my ($url, $token, @files) = @ARGV;
$token //= '';

die "‚ö† You must provide an URL\n" unless $url;

my($scheme, $authority, $path, $query, $fragment) =
    $url =~ m|(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?|;

die "‚ö† The URL '$url' must use the titan scheme\n" unless $scheme and $scheme eq 'titan';
die "‚ö† The URL '$url' must have an authority\n" unless $authority;
die "‚ö† The URL '$url' must have a path\n" unless $path;
die "‚ö† The URL '$url' must not have a query\n" if $query;
die "‚ö† The URL '$url' must not have a fragment\n" if $fragment;

if (@files > 1) {
  die "‚ö† The URL '$url' must have a path that ends in a slash\n" if $path !~ /\/$/;
} elsif (not @files) {
  die "‚ö† The URL '$url' must have a path that does not end in a slash\n" if $path =~ /\/$/;
}

for my $file (@files) {
  die "‚ö† The file '$file' does not exist\n" unless -e $file;
  die "‚ö† The file '$file' cannot be read\n" unless -r $file;
}
warn "Without a token chances are slim‚Ä¶ üòÖ\n" unless $token;
say "Start typing and end your input with Ctrl-D‚Ä¶ üòÅ" if -t and not @files;
say "Reading from the pipe‚Ä¶ üòÅ" if not -t and not @files;

my ($host, $port) = split(/:/, $authority, 2);
$port //= 1965;

undef $/;
my $temp_fh; # closing this deletes the tempfile so don't do it

unless (@files) {
  my $data = <STDIN>;
  my $file;
  ($temp_fh, $file) = tempfile();
  print $temp_fh $data;
  push(@files, $file);
}

for my $file (@files) {
  open(my $fh, '<', $file) or die "‚ö† The file '$file' cannot be read: $!\n";
  my $data = <$fh>;
  close($fh);
  my $size = length($data);
  my $type = qx(/usr/bin/file --mime-type --brief $file);
  $type =~ s/\s+$//; # remove trailing whitespace

  # If the URL ends in a slash, append the URI-escaped filename without suffix
  my $furl = $url;
  if ($path =~ /\/$/) {
    my ($name) = fileparse($file, '.gmi');
    $furl .= uri_escape($name);
  }

  # create client
  my $socket = IO::Socket::SSL->new(
    PeerHost => $host,
    PeerService => $port,
    SSL_verify_mode => SSL_VERIFY_NONE)
      or die "Cannot construct client socket: $@";

  # send data in one go
  print $socket "$furl;size=$size;mime=$type;token=$token\r\n$data";

  # print response
  my $response = <$socket>;
  $response =~ s/\r//g;
  print $response;
}

close($temp_fh) if $temp_fh; # delete tempfile, if any
